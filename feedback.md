# Week 5 Feedback: CodeGen / Planning

**Authors:** [Gavin Deane, Artemiy Vishnyakov, Savira Umar]

## 1. Counterexample Problems

### Problem A_1:  [Gavin Deane]

**Task Description:**

Complete the function that takes a paragraph of text and returns a count of how many times each word appears.

Here is an example input/output pair:

Input (string):
"The quick brown fox jumps over the lazy dog. The dog was not lazy, but the fox was quick."

Output (csv):
Word,Count
the,4
quick,2
fox,2
lazy,2
dog,2
was,2
brown,1
jumps,1
over,1
not,1
but,1

**Starter Code:**

The function and example test file is found in https://github.com/GDeane/CS846_week6_counterexample/tree/main/Week5/A_1.

> A note on GenAI contribution: The code examples and test files were generated using GitHub Copilot: GPT-5.1-Codex-Max

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 2: Add Algorithmic details when logic is complex

**Prompt and Context:**

Context Given: Week6/A_1/problem_A_1.py Week6/A_1/tests/test_problem_A_1.py

> "Write a function to count word frequencies in a string. To ensure O(n) time complexity and avoid the overhead of
> high-level abstractions, implement a Trie (prefix tree) where each node stores a frequency counter. Traverse the
> string
> character by character to populate the Trie."

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.freq = 0


def count_word_frequencies(text: str) -> Dict[str, int]:
    """Return a dict of lowercase words -> counts for the given text.

    Replace the body with your implementation. The current placeholder raises
    NotImplementedError so tests will fail until you implement it.
    """
    root = TrieNode()
    current_word = ""

    def insert(word):
        node = root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.freq += 1

    for char in text:
        if char.isalpha() or char == "'":
            current_word += char.lower()
        else:
            if current_word:
                insert(current_word)
                current_word = ""
    if current_word:
        insert(current_word)

    # Collect the result
    result = {}
    def collect(node, prefix):
        if node.freq > 0:
            result[prefix] = node.freq
        for char, child in node.children.items():
            collect(child, prefix + char)
    collect(root, "")
    return result
```

**Why this is sub-optimal:**

This function is "overly clever". It requires a developer who reads it to understand the trie class, and is very prone
to bugs if any change has to be made to it. This makes it very hard to maintain.

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 2 (Revised): Specify Clear Requirements without prescribing algorithm

**Description:**

As in good requirements engineering, give the LLM clear requirements on the problem you want solved and what a
definition of done means, but do not prescribe algorithmic details.

**Reasoning:**

Prescribing algorithmic details often leads to code that might be slightly more efficient, but is overly clever and
challenging to read for other developers. This violates the KISS (Keep it simple, Stupid) principle of good code.

Prescribing algorithm also usually leads to new and untested code being created. Rather than making use of common and
thoroughly validated library functions.

**Prompt and Context:**

Context Given: Week6/A_1/problem_A_1.py Week6/A_1/tests/test_problem_A_1.py

> "In problem_A_1.py Write the function to count word frequencies in a string. The function should take in a string of
> text and return a count of how many times each word appears."

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**

```python
import re
from collections import Counter
from typing import Dict


def count_word_frequencies(text: str) -> Dict[str, int]:
    """Return a dict of lowercase words -> counts for the given text.

    Replace the body with your implementation. The current placeholder raises
    NotImplementedError so tests will fail until you implement it.
    """
    text = text.lower()
    words = re.findall(r"[a-z']+", text)
    return dict(Counter(words))
```

**Result:**

This output is highly elegant and understandable, even to someone with little understanding of Python. It relies on
thoroughly tested and optimized library functions and each step is easy to understand conceptually.

It is also very likely that the second function is significantly faster due to the optimization of library functions. In
addition, collections.Counter is optimized in C, making it substantially more performant than a manual Python trie.

---

### Problem B_1:  [Artemiy Vishnyakov]

**Task Description:**

**Starter Code:**

The function and example test file is found in https://github.com/GDeane/CS846_week6_counterexample/tree/main/Week5/B_1.

> A note on GenAI contribution: The code examples and test files were generated using GitHub Copilot: GPT-5.1-Codex-Max

---

### 2. Guidelines that didn't work for Problem B_1

#### Guideline X:

**Prompt and Context:**

Context Given:

> ""

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**

**Why this is sub-optimal:**



---

### 3. New and Updated Guidelines that worked for Problem B_1

#### Guideline X (Revised): Allow flexibility in summary length constraints

**Description:**

**Reasoning:**

**Prompt and Context:**

Context Given:

> ""

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**

**Result:**



---

### Problem C_1:  [Savira Umar]

**Task Description:**

**Starter Code:**

The function and example test file is found in https://github.com/GDeane/CS846_week6_counterexample/tree/main/Week5/C_1.

> A note on GenAI contribution: The code examples and test files were generated using GitHub Copilot: GPT-5.1-Codex-Max

---

### 2. Guidelines that didn't work for Problem C_1

#### Guideline X:

**Prompt and Context:**

Context Given:

> ""

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**

**Why this is sub-optimal:**



---

### 3. New and Updated Guidelines that worked for Problem C_1

#### Guideline X (Revised):

**Description:**

**Reasoning:**

**Prompt and Context:**

Context Given:

> ""

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**

**Result:**



---