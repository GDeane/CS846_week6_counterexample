# Week 5 Feedback: CodeGen / Planning

**Authors:** [Gavin Deane, Artemiy Vishnyakov, Savira Umar]

## 1. Counterexample Problems

### Problem A_1:  [Gavin Deane]

**Task Description:**

**Starter Code:**

The function and example test file is found in https://github.com/GDeane/CS846_week6_counterexample/tree/main/Week5/A_1.

> A note on GenAI contribution: The "legacy code" and test file was generated using GitHub Copilot: GPT-5.1-Codex-Max

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline X:

**Prompt and Context:**

Context Given:

> ""

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**



**Why this is sub-optimal:**



---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline X (Revised): Allow flexibility in summary length constraints

**Description:**


**Reasoning:**


**Prompt and Context:**

Context Given: 

> ""

**Solution or Output generated by GitHub Copilot (Grok Code Fast 1):**



**Result:**



---

### Problem B_1: Document file using existing code style [Artemiy Vishnyakov]

**Task Description:**

Generate documentation for the pool.h file.

**Starter Code:**

The relevant files are found at https://github.com/GDeane/CS846_week5_counterexample/tree/main/Week5/B_1.

> A note on GenAI contribution: Example problem code was partially created using GitHub Copilot Raptor Mini

---

### 2. Guidelines that didn't work for Problem B_1

#### Guideline 1: Provide Project-Specific Examples of Code Summaries and Context for functions/files

**Prompt and context:**

> Our project's documentation style: pool_internal.h
> Document this in pool.h
> void pool_free(MemoryPool* pool, void* ptr);

**Solution or Output generated by GitHub Copilot (Raptor Mini):**

> /**
> * @brief Returns a previously allocated block to the pool.
> *
> * Returns a block previously obtained via pool_alloc() back to the pool for reuse.
> * If ptr is NULL the function does nothing. This function is thread-safe and
> * will acquire the pool's internal lock when updating pool state.
> *
> * @param pool Memory pool to return the block to (must be initialized via pool_init())
> * @param ptr Pointer previously returned by pool_alloc(), or NULL
> * @return None
> *
> * @pre pool initialized via pool_init(); if non-NULL, ptr must be a pointer
> *      previously returned by pool_alloc() and not already freed
> * @exceptsafe No-throw
    > */

**Why this is sub-optimal:**
Though the documentation looks correct it has false details which are copied from pool_internal and do not reflect the
true implementation. It also leaks details about the internal file functions through the comment.

---

### 3. New and Updated Guidelines that worked for Problem B_1

#### Guideline 7: Enforce strict separation between access levels of files, ideally using separate chats and repositories.

**Description:**

When working with sensitive data: Limit what information the LLM can read and reference when generating a response.
Ideally have a repository level separation but at minimum have the prompt reference the fact that the internal file
details cannot be leaked.

**Reasoning:**

LLMs tend to go for the easiest answer based on recently read data and thus are prone to repeat the confidential file if
there is a pattern that matches between the public facing and private files.

**Example**

Separate repositories for differing levels of access. A note on the sensitivity level of example files.

**Prompt and context:**

> Our project's documentation style: pool_internal.h
> Document this in pool.h
> void pool_free(MemoryPool* pool, void* ptr);
> Note that pool_internal.h is an internal file and must not be leaked. Do not copy internal or implementation specific
> details.

**Solution or Output generated by GitHub Copilot (Raptor Mini):**

> /**
> * @brief Return a previously allocated block to the pool.
> *
> * The block becomes available for future allocations. If ptr is NULL or does not
> * belong to the specified pool, the function has no effect.
> *
> * @param pool Memory pool to return the block to
> * @param ptr Pointer previously obtained from pool_alloc (may be NULL)
> * @return None
> *
> * @pre pool must be initialized via pool_init()
> * @exceptsafe No-throw guarantee
    > */
    `

**Result:**

With the added note explaining that pool_internal.h is internal the output documentation does not assume details about
the similarly named function and does not leak details about the internal file. The same situation can be observed with
a larger example in example_long.txt

---

### Problem C_1: Summarize functions in session_store.py [Savira Umar]

**Task Description:**

Summarize all functions in session_store.py using Guideline 4.

**Starter Code:**

The relevant files are found in https://github.com/GDeane/CS846_week5_counterexample/tree/main/Week5/C_1.

> A note on GenAI contribution: Example problem code was created with the aid of GitHub Copilot: GPT-5.1-Codex-Max

---

### 2. Guidelines that didn't work for Problem C_1

#### Guideline 4: Document Purpose and Contract

The original guideline assumes that asking the model to summarize purpose and contract only is sufficient to produce
safe and accurate function summaries.

However, in infrastructure-style code (e.g., session managers, background services), the boundary between observable
behavior and inferred expectations is subtle. The model may unintentionally present assumptions as guarantees,
especially when side effects and concurrency are involved.

When this happens, developers may rely on behavior that the code does not actually promise.

Here I provide a counterexample where Guideline 4: Document Purpose and Contract produces a summary that is structurally
correct but semantically weak. I then propose an updated guideline that improves transparency and trust.

A major use case for AI code summarization is understanding shared infrastructure modules. These modules often include
global state mutation, background threads, and persistence side effects. If assumptions are not clearly labeled,
summaries can mislead developers about safety and guarantees.

**Prompt and Context:**

> You are performing code summarization. Follow Guideline 4 strictly: document PURPOSE and CONTRACT, not implementation.
> For each function in session_store.py, document purpose, inputs/outputs, preconditions, side effects, and usage.
> Do not describe loops or internal steps. Use UNKNOWN if unclear.

**Solution or Output generated by GitHub Copilot (GPT-5.2-Codex):**

- start_sweeper: Starts a daemon thread; mutates session store; emits telemetry events.
- create_session: Writes to session store; increments telemetry counters.
- validate_token: Reads store and emits telemetry events.

**Why this is weak:**

Although the output follows the requested structure, it has several issues:

- It presents inferred behavior as factual guarantees
- It does not clearly distinguish assumptions from verified behavior
- It lacks explicit uncertainty labeling
- It blends observable contract with interpretation

This reduces clarity and developer trust.

---

### 3. New and Updated Guidelines that worked for Problem C_1

#### Guideline 4 (improved): Evidence-Based Function Contracts

When summarizing functions:

- Separate verified behavior from assumptions
- Label inferred expectations explicitly as ASSUMPTION
- Use UNKNOWN when behavior cannot be verified
- Explicitly document visible side effects
- Focus strictly on observable contracts

**Improved Prompt:**

Summarize session_store.py functions using evidence only.

Label inferred behavior as ASSUMPTION.

Use UNKNOWN when unclear.

Describe only observable contracts and side effects.

**Solution or Output generated by GitHub Copilot (GPT-5.2-Codex):**

- Function: start_sweeper
- Starts a background thread that removes expired sessions.
- Side effects: mutates \_SESSIONS, emits telemetry events, starts a daemon thread.
- ASSUMPTION: Intended to be called once at startup.
- UNKNOWN: Whether sweep interval is configurable beyond the parameter.
- Function: create_session
- Creates a session record and returns a signed token.
- Side effects: writes to \_SESSIONS, increments counters, records events.
- ASSUMPTION: Duplicate session IDs overwrite old sessions.
- UNKNOWN: Constraints on TTL values.
- Function: validate_token
- Validates token signature and expiration and returns user ID if valid.
- Side effects: reads \_SESSIONS, emits failure events and counters.
- ASSUMPTION: Token format matches create_session output.
- UNKNOWN: Whether failure types are externally distinguishable.
- Function: save_to_disk
- Writes session store to disk as JSON.
- Side effects: file I/O and telemetry logging.
- ASSUMPTION: Existing files are overwritten.
- UNKNOWN: Handling of serialization edge cases.
- Function: load_from_disk
- Loads session data from disk and replaces in-memory store.
- Side effects: file I/O and telemetry logging.
- ASSUMPTION: JSON structure matches expected format.
- UNKNOWN: Behavior on malformed JSON.

---

### Problem C_2: Repository-level plan [Savira Umar]

**Task Description:**

Generate a repository-level plan describing how session_store.py interacts with the repository.

**Starter Code:**

The relevant files are found in https://github.com/GDeane/CS846_week5_counterexample/tree/main/Week5/C_1.

> A note on GenAI contribution: Example problem code was created with the aid of GitHub Copilot: GPT-5.2-Codex

---

### 2. Guidelines that didn't work for Problem C_2

Guideline 6 asks the model to generate a high-level repository plan. When repository context is incomplete, however,
models may invent architecture or relationships that are not grounded in the code.

This creates hallucinated structure and reduces reliability.

#### Guideline 6: Repository-Level Planning

**Prompt and Context:**

> Create a high-level repository plan explaining the role of session_store.py, dependencies, callers, and data flow.
> Do not guess. Use UNKNOWN if unclear.

**Solution or Output generated by GitHub Copilot (GPT-5.2-Codex):**

session_store.py is used by app.py and manages session lifecycle.

**Why this is weak:**

The output:

- Assumes architectural intent
- Does not justify claims with evidence
- Fails to cite where relationships are observed
- Risks hallucinating repository structure

Even when partially correct, the lack of explicit evidence reduces trust.

---

### 3. New and Updated Guidelines that worked for Problem C_2

#### Guideline 6 (Improved): Evidence-Only Repository Planning

When creating repository plans:

- Describe only relationships supported by visible code
- Never infer architecture beyond explicit imports
- Use UNKNOWN for missing information
- Cite evidence from files when possible

**Prompt and Context:**

Generate an evidence-based repository plan.
Cite observable relationships only.
Use UNKNOWN where evidence is missing.

**Solution or Output generated by GitHub Copilot:**

Repository contains Python modules:

- app.py imports and calls functions from session_store.py
- session_store.py imports from crypto_utils.py and telemetry.py

Role of session_store.py:
Provides session creation, validation, and persistence utilities used by app.py.

Data flow:
app.py → session_store.py → crypto_utils.py / telemetry.py → disk

---